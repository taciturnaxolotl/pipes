package outputs

import (
	"context"
	"encoding/xml"
	"fmt"
	"time"

	"github.com/kierank/pipes/nodes"
)

type RSSOutputNode struct{}

func (n *RSSOutputNode) Type() string        { return "rss-output" }
func (n *RSSOutputNode) Label() string       { return "RSS Output" }
func (n *RSSOutputNode) Description() string { return "Output data as RSS feed" }
func (n *RSSOutputNode) Category() string    { return "output" }
func (n *RSSOutputNode) Inputs() int         { return 1 }
func (n *RSSOutputNode) Outputs() int        { return 0 }

func (n *RSSOutputNode) Execute(ctx context.Context, config map[string]interface{}, inputs [][]interface{}, execCtx *nodes.Context) ([]interface{}, error) {
	if len(inputs) == 0 || len(inputs[0]) == 0 {
		execCtx.Log("rss-output", "info", "No input data")
		return nil, nil
	}

	data := inputs[0]

	// Get feed metadata from config
	feedTitle := getStringConfig(config, "title", "Pipes Feed")
	feedDescription := getStringConfig(config, "description", "Feed generated by Pipes")
	feedLink := getStringConfig(config, "link", "http://localhost:3001")

	// Build RSS feed
	type RSSItem struct {
		Title       string   `xml:"title"`
		Description string   `xml:"description"`
		Link        string   `xml:"link"`
		PubDate     string   `xml:"pubDate,omitempty"`
		GUID        string   `xml:"guid,omitempty"`
		Author      string   `xml:"author,omitempty"`
		Categories  []string `xml:"category,omitempty"`
	}

	type RSSChannel struct {
		Title       string    `xml:"title"`
		Description string    `xml:"description"`
		Link        string    `xml:"link"`
		Items       []RSSItem `xml:"item"`
	}

	type RSS struct {
		XMLName xml.Name   `xml:"rss"`
		Version string     `xml:"version,attr"`
		Channel RSSChannel `xml:"channel"`
	}

	var items []RSSItem
	for _, item := range data {
		itemMap, ok := item.(map[string]interface{})
		if !ok {
			continue
		}

		rssItem := RSSItem{
			Title:       getStringFromMap(itemMap, "title", "Untitled"),
			Description: getStringFromMap(itemMap, "description", ""),
			Link:        getStringFromMap(itemMap, "link", ""),
			GUID:        getStringFromMap(itemMap, "guid", ""),
			Author:      getStringFromMap(itemMap, "author", ""),
		}

		// Try to get published date - check "published" first, then fall back to "published_at" timestamp
		if pubDate, ok := itemMap["published"].(string); ok && pubDate != "" {
			rssItem.PubDate = pubDate
		} else if timestamp, ok := itemMap["published_at"].(int64); ok && timestamp > 0 {
			// Convert Unix timestamp to RFC1123 format for RSS
			rssItem.PubDate = time.Unix(timestamp, 0).UTC().Format(time.RFC1123Z)
		}

		// Extract categories if present
		if categories, ok := itemMap["categories"].([]interface{}); ok {
			for _, cat := range categories {
				if catStr, ok := cat.(string); ok {
					rssItem.Categories = append(rssItem.Categories, catStr)
				}
			}
		}

		items = append(items, rssItem)
	}

	feed := RSS{
		Version: "2.0",
		Channel: RSSChannel{
			Title:       feedTitle,
			Description: feedDescription,
			Link:        feedLink,
			Items:       items,
		},
	}

	xmlData, err := xml.MarshalIndent(feed, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("marshal RSS: %w", err)
	}

	rssOutput := fmt.Sprintf("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n%s", string(xmlData))

	// Save output to database for public access
	if err := execCtx.SaveOutput("rss", rssOutput, "application/rss+xml"); err != nil {
		execCtx.Log("rss-output", "error", "Failed to save output: "+err.Error())
	}

	execCtx.Log("rss-output", "info", rssOutput)

	return data, nil
}

func (n *RSSOutputNode) ValidateConfig(config map[string]interface{}) error {
	return nil
}

func (n *RSSOutputNode) GetConfigSchema() *nodes.ConfigSchema {
	return &nodes.ConfigSchema{
		Fields: []nodes.ConfigField{
			{
				Name:         "title",
				Label:        "Feed Title",
				Type:         "text",
				Required:     false,
				DefaultValue: "Pipes Feed",
				HelpText:     "Title of the RSS feed",
			},
			{
				Name:         "description",
				Label:        "Feed Description",
				Type:         "textarea",
				Required:     false,
				DefaultValue: "Feed generated by Pipes",
				HelpText:     "Description of the RSS feed",
			},
			{
				Name:         "link",
				Label:        "Feed Link",
				Type:         "url",
				Required:     false,
				DefaultValue: "http://localhost:3001",
				HelpText:     "URL of the feed",
			},
		},
	}
}

func getStringConfig(config map[string]interface{}, key, defaultValue string) string {
	if val, ok := config[key].(string); ok && val != "" {
		return val
	}
	return defaultValue
}

func getStringFromMap(m map[string]interface{}, key, defaultValue string) string {
	if val, ok := m[key].(string); ok {
		return val
	}
	return defaultValue
}
