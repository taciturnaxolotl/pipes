package outputs

import (
	"context"
	"encoding/xml"
	"fmt"

	"github.com/kierank/pipes/nodes"
)

type RSSOutputNode struct{}

func (n *RSSOutputNode) Type() string        { return "rss-output" }
func (n *RSSOutputNode) Label() string       { return "RSS Output" }
func (n *RSSOutputNode) Description() string { return "Output data as RSS feed" }
func (n *RSSOutputNode) Category() string    { return "output" }
func (n *RSSOutputNode) Inputs() int         { return 1 }
func (n *RSSOutputNode) Outputs() int        { return 0 }

func (n *RSSOutputNode) Execute(ctx context.Context, config map[string]interface{}, inputs [][]interface{}, execCtx *nodes.Context) ([]interface{}, error) {
	if len(inputs) == 0 || len(inputs[0]) == 0 {
		execCtx.Log("rss-output", "info", "No input data")
		return nil, nil
	}

	data := inputs[0]

	// Get feed metadata from config
	feedTitle := getStringConfig(config, "title", "Pipes Feed")
	feedDescription := getStringConfig(config, "description", "Feed generated by Pipes")
	feedLink := getStringConfig(config, "link", "http://localhost:3001")

	// Build RSS feed
	type RSSItem struct {
		Title       string `xml:"title"`
		Description string `xml:"description"`
		Link        string `xml:"link"`
		PubDate     string `xml:"pubDate,omitempty"`
	}

	type RSSChannel struct {
		Title       string    `xml:"title"`
		Description string    `xml:"description"`
		Link        string    `xml:"link"`
		Items       []RSSItem `xml:"item"`
	}

	type RSS struct {
		XMLName xml.Name   `xml:"rss"`
		Version string     `xml:"version,attr"`
		Channel RSSChannel `xml:"channel"`
	}

	var items []RSSItem
	for _, item := range data {
		itemMap, ok := item.(map[string]interface{})
		if !ok {
			continue
		}

		rssItem := RSSItem{
			Title:       getStringFromMap(itemMap, "title", "Untitled"),
			Description: getStringFromMap(itemMap, "description", ""),
			Link:        getStringFromMap(itemMap, "link", ""),
		}

		if pubDate, ok := itemMap["pubDate"].(string); ok {
			rssItem.PubDate = pubDate
		}

		items = append(items, rssItem)
	}

	feed := RSS{
		Version: "2.0",
		Channel: RSSChannel{
			Title:       feedTitle,
			Description: feedDescription,
			Link:        feedLink,
			Items:       items,
		},
	}

	xmlData, err := xml.MarshalIndent(feed, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("marshal RSS: %w", err)
	}

	rssOutput := fmt.Sprintf("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n%s", string(xmlData))

	// Save output to database for public access
	if err := execCtx.SaveOutput("rss", rssOutput, "application/rss+xml"); err != nil {
		execCtx.Log("rss-output", "error", "Failed to save output: "+err.Error())
	}

	execCtx.Log("rss-output", "info", rssOutput)

	return data, nil
}

func (n *RSSOutputNode) ValidateConfig(config map[string]interface{}) error {
	return nil
}

func (n *RSSOutputNode) GetConfigSchema() *nodes.ConfigSchema {
	return &nodes.ConfigSchema{
		Fields: []nodes.ConfigField{
			{
				Name:         "title",
				Label:        "Feed Title",
				Type:         "text",
				Required:     false,
				DefaultValue: "Pipes Feed",
				HelpText:     "Title of the RSS feed",
			},
			{
				Name:         "description",
				Label:        "Feed Description",
				Type:         "textarea",
				Required:     false,
				DefaultValue: "Feed generated by Pipes",
				HelpText:     "Description of the RSS feed",
			},
			{
				Name:         "link",
				Label:        "Feed Link",
				Type:         "url",
				Required:     false,
				DefaultValue: "http://localhost:3001",
				HelpText:     "URL of the feed",
			},
		},
	}
}

func getStringConfig(config map[string]interface{}, key, defaultValue string) string {
	if val, ok := config[key].(string); ok && val != "" {
		return val
	}
	return defaultValue
}

func getStringFromMap(m map[string]interface{}, key, defaultValue string) string {
	if val, ok := m[key].(string); ok {
		return val
	}
	return defaultValue
}
