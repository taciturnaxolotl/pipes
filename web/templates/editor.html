<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{.Pipe.Name}} - Pipes</title>
    <link rel="icon" type="image/svg+xml" href="/public/favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300..700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Space Grotesk', sans-serif;
            background: #f5f5f0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            background: #fff;
            border-bottom: 4px solid #26242b;
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 0 #26242b;
            z-index: 100;
        }
        .pipe-name {
            color: #26242b;
            font-size: 24px;
            font-weight: 700;
            text-transform: uppercase;
        }
        .pipe-name .accent {
            color: #2563eb;
        }
        .header-actions {
            display: flex;
            gap: 12px;
        }
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background: #ff6b35;
            color: #fff;
            border: 3px solid #26242b;
            font-size: 14px;
            font-weight: 700;
            text-decoration: none;
            font-family: 'Space Grotesk', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.05rem;
            box-shadow: 4px 4px 0 #26242b;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .btn:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 #26242b;
        }
        .btn:active {
            transform: translate(4px, 4px);
            box-shadow: 0 0 0 #26242b;
        }
        .btn-secondary {
            background: #2563eb;
        }
        .btn-small {
            padding: 8px 16px;
            font-size: 12px;
            box-shadow: 3px 3px 0 #26242b;
        }

        /* Editor Layout */
        .editor-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Node Palette */
        .node-palette {
            width: 280px;
            background: #fff;
            border-right: 4px solid #26242b;
            overflow-y: auto;
            padding: 20px;
        }
        .palette-title {
            color: #26242b;
            font-size: 16px;
            font-weight: 700;
            text-transform: uppercase;
            margin-bottom: 16px;
        }
        .node-category {
            margin-bottom: 24px;
        }
        .category-title {
            color: #666;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            margin-bottom: 8px;
            letter-spacing: 0.05em;
        }
        .palette-node {
            background: #f5f5f0;
            border: 3px solid #26242b;
            padding: 12px;
            margin-bottom: 8px;
            cursor: grab;
            transition: all 0.15s ease;
        }
        .palette-node:hover {
            background: #fff;
            transform: translateX(4px);
        }
        .palette-node:active {
            cursor: grabbing;
        }
        .palette-node-name {
            font-weight: 700;
            font-size: 14px;
            color: #26242b;
            margin-bottom: 4px;
        }
        .palette-node-desc {
            font-size: 11px;
            color: #666;
            line-height: 1.4;
        }

        /* Canvas */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .node {
            position: absolute;
            background: #fff;
            border: 3px solid #26242b;
            min-width: 180px;
            box-shadow: 4px 4px 0 #26242b;
            cursor: move;
            z-index: 10;
        }
        .node.selected {
            border-color: #2563eb;
            box-shadow: 4px 4px 0 #2563eb;
            z-index: 20;
        }
        .node-header {
            background: #26242b;
            color: #fff;
            padding: 8px 12px;
            font-weight: 700;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        .node-body {
            padding: 12px;
        }
        .node-type {
            font-size: 11px;
            color: #666;
            margin-bottom: 8px;
        }
        .node-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #2563eb;
            border: 2px solid #26242b;
            cursor: crosshair;
        }
        .node-handle.input {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }
        .node-handle.output {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }
        .node-handle:hover {
            background: #ff6b35;
            width: 16px;
            height: 16px;
        }

        /* Config Panel */
        .config-panel {
            width: 320px;
            background: #fff;
            border-left: 4px solid #26242b;
            overflow-y: auto;
            padding: 20px;
            display: none;
        }
        .config-panel.visible {
            display: block;
        }
        .config-title {
            color: #26242b;
            font-size: 16px;
            font-weight: 700;
            text-transform: uppercase;
            margin-bottom: 16px;
        }
        .form-group {
            margin-bottom: 16px;
        }
        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 700;
            color: #26242b;
            text-transform: uppercase;
            margin-bottom: 6px;
            letter-spacing: 0.03em;
        }
        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 10px;
            border: 3px solid #26242b;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 14px;
            background: #f5f5f0;
        }
        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: #2563eb;
            background: #fff;
        }
        .form-textarea {
            min-height: 80px;
            resize: vertical;
        }
        .form-help {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }
        .delete-node-btn {
            background: #dc2626;
            width: 100%;
            margin-top: 20px;
        }
        .btn-view-output {
            background: #2563eb;
            width: 100%;
            margin-top: 8px;
        }
        .output-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 3px solid #26242b;
        }
        .output-title {
            font-size: 12px;
            font-weight: 700;
            color: #26242b;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .output-content {
            background: #f5f5f0;
            border: 3px solid #26242b;
            padding: 12px;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        .output-content pre {
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .output-content.rss-view {
            font-family: monospace;
        }
        .output-content.rss-view pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .output-content.rss-view .key {
            color: #2563eb;
            font-weight: 700;
        }
        .output-empty {
            color: #666;
            font-style: italic;
            font-family: monospace;
        }

        /* Toast Notifications */
        #toast-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: none;
        }
        .toast {
            background: #fff;
            border: 3px solid #26242b;
            box-shadow: 4px 4px 0 #26242b;
            padding: 16px 20px;
            min-width: 280px;
            max-width: 400px;
            font-weight: 600;
            font-size: 14px;
            color: #26242b;
            pointer-events: all;
            animation: slideIn 0.2s ease;
        }
        .toast.success {
            border-left: 8px solid #2563eb;
        }
        .toast.error {
            border-left: 8px solid #dc2626;
        }
        .toast.info {
            border-left: 8px solid #ff6b35;
        }
        @keyframes slideIn {
            from {
                transform: translateX(calc(100% + 20px));
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        .toast.exit {
            animation: slideOut 0.2s ease forwards;
        }
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(calc(100% + 20px));
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="pipe-name" onclick="renamePipe()" style="cursor: pointer;" title="Click to rename">
            <span class="accent">{{.Pipe.Name}}</span>
        </div>
        <div class="header-actions">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; cursor: pointer;">
                <input type="checkbox" id="is-public" onchange="togglePublic()" {{if .Pipe.IsPublic}}checked{{end}}>
                Public
            </label>
            <button onclick="executePipe()" class="btn btn-small">‚ñ∂ Run</button>
            <button onclick="savePipe()" class="btn btn-small btn-secondary">üíæ Save</button>
            <a href="/dashboard" class="btn btn-small" style="text-decoration: none;">‚Üê Back</a>
        </div>
    </header>

    <div class="editor-container">
        <!-- Node Palette -->
        <div class="node-palette">
            <div class="palette-title">Add Nodes</div>
            <div id="node-palette"></div>
        </div>

        <!-- Canvas -->
        <div class="canvas-container" id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="nodes-container"></div>
        </div>

        <!-- Config Panel -->
        <div class="config-panel" id="config-panel">
            <div class="config-title" id="config-node-name">Node Configuration</div>
            <div id="config-form"></div>
        </div>
    </div>

    <script>
        const pipeID = "{{.Pipe.ID}}";
        let nodes = [];
        let connections = [];
        let selectedNode = null;
        let nodeTypes = [];
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };
        let connectionStart = null;
        let connectionDrag = null;
        let snapTarget = null;
        const SNAP_DISTANCE = 30;
        
        let canvas, ctx;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let panOffset = { x: 0, y: 0 };
        let spacePressed = false;

        // Utility function for HTML escaping
        function escapeHtml(text) {
            if (text == null) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            await loadNodeTypes();
            await loadPipe();
            renderPalette();
            render();

            // Canvas interactions
            const container = document.getElementById('canvas-container');
            container.addEventListener('click', (e) => {
                if (e.target === container || e.target === canvas) {
                    deselectNode();
                }
            });
            
            // Pan controls
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !spacePressed) {
                    spacePressed = true;
                    container.style.cursor = 'grab';
                }
            });

            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    spacePressed = false;
                    if (!isPanning) container.style.cursor = '';
                }
            });

            container.addEventListener('mousedown', (e) => {
                if (e.button === 1 || (e.button === 0 && spacePressed)) {
                    e.preventDefault();
                    isPanning = true;
                    panStart = { x: e.clientX - panOffset.x, y: e.clientY - panOffset.y };
                    container.style.cursor = 'grabbing';
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    panOffset.x = e.clientX - panStart.x;
                    panOffset.y = e.clientY - panStart.y;
                    updatePanTransform();
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 1 || e.button === 0) {
                    if (isPanning) {
                        isPanning = false;
                        container.style.cursor = spacePressed ? 'grab' : '';
                    }
                }
            });

            // Prevent middle mouse scroll
            container.addEventListener('mousedown', (e) => {
                if (e.button === 1) e.preventDefault();
            });
        });

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
            
            render();
        }

        function updatePanTransform() {
            const nodesContainer = document.getElementById('nodes-container');
            nodesContainer.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px)`;
            render();
        }

        async function loadNodeTypes() {
            const res = await fetch('/api/node-types');
            nodeTypes = await res.json();
        }

        async function loadPipe() {
            const res = await fetch(`/api/pipes/${pipeID}`);
            const pipe = await res.json();
            console.log('Loaded pipe:', pipe);
            console.log('Config type:', typeof pipe.config);
            console.log('Config value:', pipe.config);
            if (pipe.config) {
                const config = typeof pipe.config === 'string' ? JSON.parse(pipe.config) : pipe.config;
                console.log('Parsed config:', config);
                nodes = config.nodes || [];
                connections = config.connections || [];
                console.log('Loaded nodes:', nodes);
                console.log('Loaded connections:', connections);
            }
        }

        function renderPalette() {
            const palette = document.getElementById('node-palette');
            const categories = {};

            nodeTypes.forEach(type => {
                if (!categories[type.category]) {
                    categories[type.category] = [];
                }
                categories[type.category].push(type);
            });

            Object.keys(categories).sort().forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'node-category';

                const title = document.createElement('div');
                title.className = 'category-title';
                title.textContent = category;
                categoryDiv.appendChild(title);

                categories[category].forEach(type => {
                    const node = document.createElement('div');
                    node.className = 'palette-node';
                    node.draggable = true;
                    node.dataset.type = type.type;

                    const name = document.createElement('div');
                    name.className = 'palette-node-name';
                    name.textContent = type.label;
                    node.appendChild(name);

                    const desc = document.createElement('div');
                    desc.className = 'palette-node-desc';
                    desc.textContent = type.description;
                    node.appendChild(desc);

                    node.addEventListener('dragstart', onPaletteDragStart);
                    categoryDiv.appendChild(node);
                });

                palette.appendChild(categoryDiv);
            });
        }

        function onPaletteDragStart(e) {
            e.dataTransfer.setData('nodeType', e.currentTarget.dataset.type);
        }

        // Setup drop zone
        const container = document.getElementById('canvas-container');
        container.addEventListener('dragover', (e) => e.preventDefault());
        container.addEventListener('drop', (e) => {
            e.preventDefault();
            const nodeType = e.dataTransfer.getData('nodeType');
            if (!nodeType) return;

            const rect = container.getBoundingClientRect();
            const x = e.clientX - rect.left - panOffset.x;
            const y = e.clientY - rect.top - panOffset.y;

            addNode(nodeType, x, y);
        });

        function addNode(type, x, y) {
            const nodeType = nodeTypes.find(t => t.type === type);
            if (!nodeType) return;

            const node = {
                id: generateID(),
                type: type,
                label: nodeType.label,
                position: { x, y },
                config: {}
            };

            nodes.push(node);
            render();
        }

        function render() {
            renderNodes();
            // Use requestAnimationFrame to ensure nodes are in DOM before drawing connections
            requestAnimationFrame(() => {
                renderConnections();
            });
        }

        function renderConnections() {
            const dpr = window.devicePixelRatio || 1;
            
            // Reset transform and clear canvas
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply DPR scaling and pan offset
            ctx.setTransform(dpr, 0, 0, dpr, panOffset.x * dpr, panOffset.y * dpr);
            
            ctx.strokeStyle = '#26242b';
            ctx.lineWidth = 3;

            connections.forEach(conn => {
                const source = nodes.find(n => n.id === conn.source);
                const target = nodes.find(n => n.id === conn.target);
                if (!source || !target) return;

                const sourceEl = document.getElementById(`node-${source.id}`);
                const targetEl = document.getElementById(`node-${target.id}`);
                if (!sourceEl || !targetEl) return;

                // Use actual dimensions from DOM elements
                const sourceWidth = sourceEl.offsetWidth;
                const sourceHeight = sourceEl.offsetHeight;
                const targetWidth = targetEl.offsetWidth;
                const targetHeight = targetEl.offsetHeight;

                // Calculate positions from node data (already in local coordinates)
                const x1 = source.position.x + sourceWidth;
                const y1 = source.position.y + sourceHeight / 2;
                const x2 = target.position.x;
                const y2 = target.position.y + targetHeight / 2;

                // Create path for hit detection
                const path = new Path2D();
                path.moveTo(x1, y1);
                const mx = (x1 + x2) / 2;
                path.bezierCurveTo(mx, y1, mx, y2, x2, y2);
                
                // Store path for click detection
                conn._path = path;
                conn._transform = { dpr, panOffset };
                conn._midpoint = { x: mx, y: (y1 + y2) / 2 };

                // Draw connection with deletion animation
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.bezierCurveTo(mx, y1, mx, y2, x2, y2);
                
                // Apply deletion animation
                if (conn._deleting) {
                    const elapsed = Date.now() - conn._deleteTime;
                    const progress = Math.min(elapsed / 200, 1);
                    const alpha = 1 - progress;
                    
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = '#dc2626'; // Red color for deletion
                    ctx.lineWidth = 5;
                    ctx.setLineDash([10, 5]);
                } else {
                    ctx.strokeStyle = '#26242b';
                    ctx.lineWidth = 3;
                }
                
                ctx.stroke();
                ctx.globalAlpha = 1;
                ctx.setLineDash([]);
            });
            
            // Draw temporary connection while dragging
            if (connectionStart && connectionDrag) {
                const source = nodes.find(n => n.id === connectionStart.nodeID);
                if (source) {
                    const sourceEl = document.getElementById(`node-${source.id}`);
                    if (sourceEl) {
                        const sourceWidth = sourceEl.offsetWidth;
                        const sourceHeight = sourceEl.offsetHeight;
                        
                        const x1 = source.position.x + sourceWidth;
                        const y1 = source.position.y + sourceHeight / 2;
                        
                        let x2 = connectionDrag.x;
                        let y2 = connectionDrag.y;
                        
                        // Snap to target if close enough
                        if (snapTarget) {
                            x2 = snapTarget.x;
                            y2 = snapTarget.y;
                            
                            // Draw snap indicator
                            ctx.save();
                            ctx.fillStyle = '#2563eb';
                            ctx.globalAlpha = 0.3;
                            ctx.beginPath();
                            ctx.arc(x2, y2, 20, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                        
                        // Draw temporary connection line
                        ctx.save();
                        ctx.strokeStyle = snapTarget ? '#2563eb' : '#666';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        const mx = (x1 + x2) / 2;
                        ctx.bezierCurveTo(mx, y1, mx, y2, x2, y2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
        }

        function renderNodes() {
            const container = document.getElementById('nodes-container');
            container.innerHTML = '';

            nodes.forEach(node => {
                const el = document.createElement('div');
                el.id = `node-${node.id}`;
                el.className = 'node';
                if (selectedNode === node.id) el.classList.add('selected');
                el.style.left = `${node.position.x}px`;
                el.style.top = `${node.position.y}px`;

                const header = document.createElement('div');
                header.className = 'node-header';
                header.textContent = node.label;
                el.appendChild(header);

                const body = document.createElement('div');
                body.className = 'node-body';

                const type = document.createElement('div');
                type.className = 'node-type';
                type.textContent = node.type;
                body.appendChild(type);

                el.appendChild(body);

                // Handles
                const nodeType = nodeTypes.find(t => t.type === node.type);
                if (nodeType && nodeType.category !== 'source') {
                    const inputHandle = document.createElement('div');
                    inputHandle.className = 'node-handle input';
                    inputHandle.addEventListener('mousedown', (e) => onHandleMouseDown(e, node.id, 'input'));
                    el.appendChild(inputHandle);
                }

                if (nodeType && nodeType.category !== 'output') {
                    const outputHandle = document.createElement('div');
                    outputHandle.className = 'node-handle output';
                    outputHandle.addEventListener('mousedown', (e) => onHandleMouseDown(e, node.id, 'output'));
                    el.appendChild(outputHandle);
                }

                el.addEventListener('mousedown', (e) => onNodeMouseDown(e, node.id));
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectNode(node.id);
                });

                container.appendChild(el);
            });
        }

        function onNodeMouseDown(e, nodeID) {
            if (e.target.classList.contains('node-handle')) return;

            const node = nodes.find(n => n.id === nodeID);
            draggedNode = node;

            const nodeEl = document.getElementById(`node-${nodeID}`);
            const rect = nodeEl.getBoundingClientRect();
            const containerRect = document.getElementById('canvas-container').getBoundingClientRect();

            dragOffset = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };

            document.addEventListener('mousemove', onNodeMouseMove);
            document.addEventListener('mouseup', onNodeMouseUp);
        }

        function onNodeMouseMove(e) {
            if (!draggedNode) return;

            const containerRect = document.getElementById('canvas-container').getBoundingClientRect();
            draggedNode.position.x = e.clientX - containerRect.left - dragOffset.x - panOffset.x;
            draggedNode.position.y = e.clientY - containerRect.top - dragOffset.y - panOffset.y;

            render();
        }

        function onNodeMouseUp() {
            draggedNode = null;
            document.removeEventListener('mousemove', onNodeMouseMove);
            document.removeEventListener('mouseup', onNodeMouseUp);
        }

        function onHandleMouseDown(e, nodeID, handleType) {
            e.stopPropagation();
            e.preventDefault();

            if (handleType === 'output') {
                // Check if there's an existing connection to delete
                const existing = connections.filter(c => c.source === nodeID);
                if (existing.length > 0 && e.shiftKey) {
                    // Shift+click to delete outgoing connections
                    existing.forEach(conn => {
                        const index = connections.indexOf(conn);
                        if (index !== -1) connections.splice(index, 1);
                    });
                    render();
                    showToast(`Deleted ${existing.length} connection${existing.length > 1 ? 's' : ''}`, 'info');
                    return;
                }
                
                connectionStart = { nodeID, handleType };
                document.addEventListener('mousemove', onConnectionMouseMove);
                document.addEventListener('mouseup', onConnectionMouseUp);
            } else {
                // Input handle - delete incoming connections
                const existing = connections.filter(c => c.target === nodeID);
                if (existing.length > 0) {
                    existing.forEach(conn => {
                        const index = connections.indexOf(conn);
                        if (index !== -1) connections.splice(index, 1);
                    });
                    render();
                    showToast(`Deleted ${existing.length} connection${existing.length > 1 ? 's' : ''}`, 'info');
                }
            }
        }

        function onConnectionMouseMove(e) {
            const containerRect = document.getElementById('canvas-container').getBoundingClientRect();
            const mouseX = e.clientX - containerRect.left - panOffset.x;
            const mouseY = e.clientY - containerRect.top - panOffset.y;
            
            connectionDrag = { x: mouseX, y: mouseY };
            
            // Check for snap targets
            snapTarget = null;
            let minDist = SNAP_DISTANCE;
            
            nodes.forEach(node => {
                if (node.id === connectionStart.nodeID) return;
                const nodeType = nodeTypes.find(t => t.type === node.type);
                if (!nodeType || nodeType.category === 'source') return;
                
                // Calculate input handle position using actual node dimensions
                const nodeEl = document.getElementById(`node-${node.id}`);
                if (!nodeEl) return;
                
                const handleX = node.position.x;
                const handleY = node.position.y + nodeEl.offsetHeight / 2;
                
                const dist = Math.sqrt((mouseX - handleX) ** 2 + (mouseY - handleY) ** 2);
                if (dist < minDist) {
                    minDist = dist;
                    snapTarget = { nodeID: node.id, x: handleX, y: handleY };
                }
            });
            
            render();
        }

        function onConnectionMouseUp(e) {
            if (!connectionStart) return;

            let targetID = null;
            
            // Use snap target if available
            if (snapTarget) {
                targetID = snapTarget.nodeID;
            } else {
                // Fallback to exact handle hit detection
                const target = e.target;
                if (target.classList.contains('node-handle') && target.classList.contains('input')) {
                    const targetNode = target.closest('.node');
                    targetID = targetNode.id.replace('node-', '');
                }
            }
            
            // Create connection if valid and not duplicate
            if (targetID && targetID !== connectionStart.nodeID) {
                const exists = connections.some(c => c.source === connectionStart.nodeID && c.target === targetID);
                if (!exists) {
                    connections.push({
                        id: generateID(),
                        source: connectionStart.nodeID,
                        target: targetID
                    });
                }
            }

            connectionStart = null;
            connectionDrag = null;
            snapTarget = null;
            document.removeEventListener('mousemove', onConnectionMouseMove);
            document.removeEventListener('mouseup', onConnectionMouseUp);
            render();
        }

        function selectNode(nodeID) {
            selectedNode = nodeID;
            render();
            showConfigPanel(nodeID);
            viewNodeData(nodeID);
        }

        function deselectNode() {
            selectedNode = null;
            render();
            document.getElementById('config-panel').classList.remove('visible');
        }

        function showConfigPanel(nodeID) {
            const node = nodes.find(n => n.id === nodeID);
            const nodeType = nodeTypes.find(t => t.type === node.type);

            document.getElementById('config-node-name').textContent = node.label;
            document.getElementById('config-panel').classList.add('visible');

            const form = document.getElementById('config-form');
            form.innerHTML = '';

            if (!nodeType.schema || !nodeType.schema.fields) {
                form.innerHTML = '<p style="color: #666;">No configuration needed</p>';
                return;
            }

            nodeType.schema.fields.forEach(field => {
                const group = document.createElement('div');
                group.className = 'form-group';

                const label = document.createElement('label');
                label.className = 'form-label';
                label.textContent = field.label;
                group.appendChild(label);

                let input;
                if (field.type === 'select') {
                    input = document.createElement('select');
                    input.className = 'form-select';
                    field.options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.label;
                        input.appendChild(option);
                    });
                } else if (field.type === 'textarea') {
                    input = document.createElement('textarea');
                    input.className = 'form-textarea';
                } else {
                    input = document.createElement('input');
                    input.className = 'form-input';
                    input.type = field.type === 'number' ? 'number' : 'text';
                }

                input.value = node.config[field.name] || field.defaultValue || '';
                input.addEventListener('change', async (e) => {
                    node.config[field.name] = e.target.value;
                    
                    // Auto-fetch feed title for RSS source URL field
                    if (node.type === 'rss-source' && field.name === 'url' && e.target.value) {
                        try {
                            const res = await fetch(`/api/feed-info?url=${encodeURIComponent(e.target.value)}`);
                            if (res.ok) {
                                const info = await res.json();
                                if (info.title && node.label === 'RSS Feed') {
                                    node.label = info.title;
                                    render();
                                    showToast(`Feed: ${info.title}`, 'success');
                                }
                            }
                        } catch (err) {
                            // Ignore fetch errors
                        }
                    }
                });

                group.appendChild(input);

                if (field.helpText) {
                    const help = document.createElement('div');
                    help.className = 'form-help';
                    help.textContent = field.helpText;
                    group.appendChild(help);
                }

                form.appendChild(group);
            });

            // Show feed URL for output nodes
            if (nodeType.category === 'output') {
                const feedSection = document.createElement('div');
                feedSection.className = 'output-section';
                feedSection.style.marginTop = '20px';

                const feedTitle = document.createElement('div');
                feedTitle.className = 'output-title';
                feedTitle.textContent = 'Public Feed URL';
                feedSection.appendChild(feedTitle);

                const format = node.type === 'rss-output' ? 'rss' : 'json';
                const feedUrl = `${window.location.origin}/feeds/${pipeID}.${format}`;

                const feedLink = document.createElement('div');
                feedLink.style.cssText = 'display: flex; gap: 8px; align-items: center;';
                
                const feedInput = document.createElement('input');
                feedInput.className = 'form-input';
                feedInput.type = 'text';
                feedInput.value = feedUrl;
                feedInput.readOnly = true;
                feedInput.style.flex = '1';
                feedLink.appendChild(feedInput);

                const copyBtn = document.createElement('button');
                copyBtn.className = 'btn btn-small';
                copyBtn.textContent = 'üìã';
                copyBtn.title = 'Copy URL';
                copyBtn.onclick = () => {
                    navigator.clipboard.writeText(feedUrl);
                    showToast('URL copied!', 'success');
                };
                feedLink.appendChild(copyBtn);

                const openBtn = document.createElement('button');
                openBtn.className = 'btn btn-small';
                openBtn.textContent = '‚Üó';
                openBtn.title = 'Open feed';
                openBtn.onclick = () => window.open(feedUrl, '_blank');
                feedLink.appendChild(openBtn);

                feedSection.appendChild(feedLink);

                const feedHelp = document.createElement('div');
                feedHelp.className = 'form-help';
                feedHelp.textContent = 'Make pipe public and run it to generate the feed.';
                feedSection.appendChild(feedHelp);

                form.appendChild(feedSection);
            }

            // Data display section (always visible)
            const dataSection = document.createElement('div');
            dataSection.className = 'output-section';
            dataSection.style.marginTop = '20px';

            const dataTitle = document.createElement('div');
            dataTitle.className = 'output-title';
            dataTitle.textContent = 'Node Data';
            dataSection.appendChild(dataTitle);

            const dataContent = document.createElement('div');
            dataContent.className = 'output-content output-empty';
            dataContent.id = `data-content-${nodeID}`;
            dataContent.textContent = 'Run the pipe to see data';
            dataSection.appendChild(dataContent);

            form.appendChild(dataSection);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'btn delete-node-btn';
            deleteBtn.textContent = 'üóë Delete Node';
            deleteBtn.style.marginTop = '20px';
            deleteBtn.onclick = () => deleteNode(nodeID);
            form.appendChild(deleteBtn);
        }

        function deleteNode(nodeID) {
            nodes = nodes.filter(n => n.id !== nodeID);
            connections = connections.filter(c => c.source !== nodeID && c.target !== nodeID);
            deselectNode();
            render();
        }

        async function renamePipe() {
            const newName = prompt('Enter new pipe name:', document.querySelector('.pipe-name .accent').textContent);
            if (!newName || newName.trim() === '') return;

            const res = await fetch(`/api/pipes/${pipeID}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newName.trim() })
            });

            if (res.ok) {
                document.querySelector('.pipe-name .accent').textContent = newName.trim();
                document.title = `${newName.trim()} - Pipes`;
                showToast('Pipe renamed', 'success');
            } else {
                showToast('Failed to rename pipe', 'error');
            }
        }

        let executionStatusInterval = null;

        async function togglePublic() {
            const isPublic = document.getElementById('is-public').checked;
            
            const res = await fetch(`/api/pipes/${pipeID}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ is_public: isPublic })
            });

            if (res.ok) {
                showToast(isPublic ? 'Pipe is now public' : 'Pipe is now private', 'success');
            } else {
                showToast('Failed to update visibility', 'error');
                document.getElementById('is-public').checked = !isPublic;
            }
        }

        async function viewNodeData(nodeID) {
            const dataContent = document.getElementById(`data-content-${nodeID}`);
            if (!dataContent) return;

            dataContent.className = 'output-content output-empty';
            dataContent.textContent = 'Loading...';

            try {
                // Get latest execution
                const execRes = await fetch(`/api/pipes/${pipeID}/executions?limit=1`);
                if (!execRes.ok) throw new Error('No executions found');
                
                const executions = await execRes.json();
                if (!executions || executions.length === 0) {
                    dataContent.textContent = 'No executions yet. Run the pipe first.';
                    return;
                }

                const execution = executions[0];
                const executionId = execution.id;
                
                // Get logs for this node
                const logsRes = await fetch(`/api/executions/${executionId}/logs`);
                if (!logsRes.ok) throw new Error('Failed to fetch logs');
                
                const logs = await logsRes.json();
                const dataLog = logs.find(log => log.node_id === nodeID && log.level === 'data');
                
                if (!dataLog || !dataLog.metadata) {
                    dataContent.textContent = 'No data available for this node.';
                    return;
                }

                // Parse and display the data
                const data = JSON.parse(dataLog.metadata);
                dataContent.className = 'output-content';
                
                // Format data based on node type or data structure
                const node = nodes.find(n => n.id === nodeID);
                const isRSSData = Array.isArray(data) && data.length > 0 && 
                    data[0].title && (data[0].link || data[0].published || data[0].published_at);
                
                if ((node && node.type === 'rss-source' && Array.isArray(data)) || isRSSData) {
                    // Format RSS items with colored field names
                    dataContent.classList.add('rss-view');
                    let html = '<pre>';
                    data.forEach((item, idx) => {
                        html += `<span class="key">title:</span> ${escapeHtml(item.title || '')}\n`;
                        if (item.link) {
                            html += `<span class="key">link:</span> ${escapeHtml(item.link)}\n`;
                        }
                        if (item.author) {
                            html += `<span class="key">author:</span> ${escapeHtml(item.author)}\n`;
                        }
                        if (item.published) {
                            html += `<span class="key">published:</span> ${escapeHtml(item.published)}\n`;
                        }
                        if (item.published_at) {
                            const date = new Date(item.published_at * 1000);
                            html += `<span class="key">published_at:</span> ${item.published_at} (${date.toLocaleString()})\n`;
                        }
                        if (item.updated_at) {
                            const date = new Date(item.updated_at * 1000);
                            html += `<span class="key">updated_at:</span> ${item.updated_at} (${date.toLocaleString()})\n`;
                        }
                        if (item.categories && item.categories.length > 0) {
                            html += `<span class="key">categories:</span> ${escapeHtml(item.categories.join(', '))}\n`;
                        }
                        if (item.description) {
                            const preview = item.description.length > 200 ? item.description.substring(0, 200) + '...' : item.description;
                            html += `<span class="key">description:</span> ${escapeHtml(preview)}\n`;
                        }
                        if (item.content && item.content !== item.description) {
                            const preview = item.content.length > 200 ? item.content.substring(0, 200) + '...' : item.content;
                            html += `<span class="key">content:</span> ${escapeHtml(preview)}\n`;
                        }
                        if (item.image) {
                            html += `<span class="key">image:</span> ${escapeHtml(item.image)}\n`;
                        }
                        if (item.enclosures && item.enclosures.length > 0) {
                            html += `<span class="key">enclosures:</span> ${item.enclosures.length} file(s)\n`;
                            item.enclosures.forEach(enc => {
                                html += `  - ${escapeHtml(enc.type || 'unknown')}: ${escapeHtml(enc.url)}\n`;
                            });
                        }
                        html += '\n';
                    });
                    html += '</pre>';
                    dataContent.innerHTML = html;
                } else {
                    // Display as formatted JSON (escaped)
                    const jsonStr = JSON.stringify(data, null, 2);
                    const escaped = escapeHtml(jsonStr);
                    dataContent.innerHTML = `<pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word;">${escaped}</pre>`;
                }
            } catch (err) {
                dataContent.className = 'output-content output-empty';
                dataContent.textContent = `Error: ${err.message}`;
            }
        }

        async function savePipe() {
            const config = {
                version: "1",
                nodes: nodes,
                connections: connections,
                settings: { enabled: false }
            };

            console.log('Saving config:', config);

            const res = await fetch(`/api/pipes/${pipeID}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ config: config })
            });

            if (res.ok) {
                showToast('Pipe saved successfully!', 'success');
                const result = await res.json();
                console.log('Save result:', result);
            } else {
                const error = await res.text();
                console.error('Save failed:', error);
                showToast('Failed to save pipe', 'error');
            }
        }

        async function executePipe() {
            // Save first
            await savePipe();
            
            const res = await fetch(`/api/pipes/${pipeID}/execute`, {
                method: 'POST'
            });

            if (res.ok) {
                const data = await res.json();
                showToast('Execution started', 'info');
                
                // Clear all data sections
                document.querySelectorAll('[id^="data-content-"]').forEach(el => {
                    el.className = 'output-content output-empty';
                    el.textContent = 'Running...';
                });
                
                // Poll for completion
                pollExecutionStatus(data.executionId);
            } else {
                const errorText = await res.text();
                showToast(errorText || 'Failed to execute pipe', 'error');
            }
        }

        async function pollExecutionStatus(executionId) {
            if (executionStatusInterval) {
                clearInterval(executionStatusInterval);
            }

            let attempts = 0;
            const maxAttempts = 30; // 30 seconds max

            executionStatusInterval = setInterval(async () => {
                attempts++;
                
                try {
                    const execRes = await fetch(`/api/pipes/${pipeID}/executions?limit=1`);
                    if (!execRes.ok) return;
                    
                    const executions = await execRes.json();
                    if (!executions || executions.length === 0) return;
                    
                    const execution = executions[0];
                    
                    if (execution.status === 'success') {
                        clearInterval(executionStatusInterval);
                        showToast('Execution completed successfully', 'success');
                        
                        // Refresh data for all nodes
                        nodes.forEach(node => {
                            const dataContent = document.getElementById(`data-content-${node.id}`);
                            if (dataContent) {
                                viewNodeData(node.id);
                            }
                        });
                    } else if (execution.status === 'failed') {
                        clearInterval(executionStatusInterval);
                        showToast(`Execution failed: ${execution.error_message || 'Unknown error'}`, 'error');
                        
                        // Clear all data sections
                        document.querySelectorAll('[id^="data-content-"]').forEach(el => {
                            el.className = 'output-content output-empty';
                            el.textContent = 'Execution failed. Check logs.';
                        });
                    }
                    
                    if (attempts >= maxAttempts) {
                        clearInterval(executionStatusInterval);
                        showToast('Execution taking longer than expected', 'info');
                    }
                } catch (err) {
                    console.error('Polling error:', err);
                }
            }, 1000); // Poll every second
        }

        function generateID() {
            return Math.random().toString(36).substring(2, 15);
        }

        // Toast notifications
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            
            // Click to dismiss
            toast.style.cursor = 'pointer';
            toast.onclick = () => {
                toast.classList.add('exit');
                setTimeout(() => container.removeChild(toast), 200);
            };

            container.appendChild(toast);

            // Auto-dismiss: errors stay longer
            const duration = type === 'error' ? 8000 : 3000;
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.classList.add('exit');
                    setTimeout(() => {
                        if (toast.parentNode) container.removeChild(toast);
                    }, 200);
                }
            }, duration);
        }
    </script>

    <!-- Toast Container -->
    <div id="toast-container"></div>
</body>
</html>
